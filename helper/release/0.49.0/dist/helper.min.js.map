{"version":3,"file":"helper.min.js","sources":["../src/groups.ts","../src/GroupManager.ts"],"sourcesContent":["import { isArray, deepFlat, find } from \"@daybrush/utils\";\nimport { GroupChild, TargetGroupsObject, TargetGroupsType } from \"./types\";\n\nexport class Child {\n    public type: \"group\" | \"root\" | \"single\" = \"single\";\n    public depth = 0;\n    protected _scope: string[] = [];\n    constructor(public parent?: ArrayChild) {\n        if (parent) {\n            this.depth = parent.depth + 1;\n        }\n    }\n\n    public get scope(): string[] {\n        const parent = this.parent;\n\n        if (!parent || parent.type === \"root\") {\n            return [];\n        }\n        return [...parent.scope, parent.id];\n    }\n}\n\nexport class SingleChild extends Child {\n    public type = \"single\" as const;\n    public isGroupElement = false;\n    constructor(parent: ArrayChild, public value: HTMLElement | SVGElement) {\n        super(parent);\n    }\n}\n\n\nexport class ArrayChild extends Child {\n    public type: \"group\" | \"root\" = \"group\";\n    public value: GroupChild[] = [];\n    public id = \"\";\n    public groupElement?: HTMLElement | SVGElement | null = null;\n    public map: Map<HTMLElement | SVGElement, SingleChild> = new Map();\n\n    public compare(groups: TargetGroupsType, checker: -1 | 0 | 1 = 0) {\n        const elements = deepFlat(groups);\n        const map = this.map;\n        const elementsLength = elements.length;\n        const mapSize = map.size;\n        const sizeDiff = mapSize - elementsLength;\n\n        // 1 this > groups\n        // 0 this = groups\n        // -1 this < groups\n        const count = elements.filter(element => map.has(element)).length;\n\n        if ((checker > 0 && sizeDiff >= 0) || (checker === 0 && sizeDiff === 0)) {\n            return elementsLength === count;\n        } else if (checker < 0 && sizeDiff <= 0) {\n            return mapSize === count;\n        }\n        return false;\n    }\n    public has(target: HTMLElement | SVGElement) {\n        return this.map.has(target);\n    }\n    public contains(element: HTMLElement | SVGElement): boolean {\n        if (this.has(element)) {\n            return true;\n        }\n        return this.value.some(child => {\n            if (child.type === \"group\") {\n                return child.contains(element);\n            } else {\n                return false;\n            }\n        });\n    }\n    public findContainedChild(element: HTMLElement | SVGElement) {\n        return find(this.value, child => {\n            if (child.type === \"single\") {\n                return child.value === element;\n            } else {\n                return child.contains(element);\n            }\n        });\n    }\n    /**\n     * Exact group containing targets\n     */\n    public findExactChild(target: TargetGroupsType[0]): GroupChild | undefined {\n        const map = this.map;\n\n        if (!isArray(target)) {\n            return map.get(target);\n        }\n        const flatted = deepFlat(target);\n        const length = flatted.length;\n        const single = map.get(flatted[0]);\n\n        if (!single) {\n            return;\n        }\n\n        let parent: ArrayChild | undefined = single.parent;\n\n        while (parent) {\n            if (parent.map.size >= length) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return;\n    }\n    public findCommonParent(targets: TargetGroupsType): ArrayChild {\n        let depth = Infinity;\n        let childs = targets.map(target => this.findExactChild(target));\n\n        childs.forEach(child => {\n            if (!child) {\n                return;\n            }\n            depth = Math.min(child.depth, depth);\n        });\n\n        while (depth) {\n            --depth;\n            childs = childs.map(child => {\n                let parent: GroupChild | undefined = child;\n\n                while (parent && parent.depth !== depth) {\n                    parent = parent.parent;\n                }\n\n                return parent;\n            });\n            const firstChild = childs.find(child => child);\n\n            if (!firstChild) {\n                return this;\n            }\n            if (childs.every(child => !child || child === firstChild)) {\n                break;\n            }\n        }\n        const commonParent = childs.find(child => child) as ArrayChild;\n\n        return commonParent || this;\n    }\n    public findNextChild(\n        target: HTMLElement | SVGElement,\n        range: TargetGroupsType = this.toTargetGroups(),\n        isExact = true,\n    ): ArrayChild | null {\n        let nextChild: ArrayChild | null = null;\n\n        const length = range.length;\n\n        range.some(child => {\n            if (!isExact && length === 1 && isArray(child)) {\n                nextChild = this.findNextChild(target, child);\n                return nextChild;\n            }\n\n\n            const nextGroupChild = this.findExactChild(child);\n\n            if (!nextGroupChild) {\n                return;\n            }\n\n            if (\"map\" in nextGroupChild) {\n                if (nextGroupChild.map.has(target)) {\n                    nextChild = nextGroupChild;\n                    return true;\n                }\n            }\n        });\n\n        return nextChild;\n    }\n    public findNextExactChild(\n        target: HTMLElement | SVGElement,\n        selected: Array<HTMLElement | SVGElement>,\n        range: TargetGroupsType = this.toTargetGroups(),\n    ): ArrayChild | null {\n        // [[1, 2]] => group([1, 2]) exact\n        // [[[1, 2], 3]] => group([1, 2])\n        const nextChild = this.findNextChild(target, range, true);\n\n        if (!nextChild) {\n            return null;\n        }\n\n        if (nextChild.compare(selected, -1)) {\n            return nextChild;\n        }\n        return null;\n    }\n    /**\n     * Finds a group that does not overlap within the range and includes the target.\n     */\n    public findPureChild(\n        target: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ): ArrayChild | null {\n        let nextGroupChild: ArrayChild | null = null;\n\n        const childSelected = range.filter(element => this.has(element));\n\n        if (!childSelected.length) {\n            return this;\n        }\n\n        this.value.some(nextChild => {\n            if (nextChild.type !== \"single\" && nextChild.has(target)) {\n                nextGroupChild = nextChild.findPureChild(target, childSelected);\n\n                if (nextGroupChild) {\n                    return true;\n                }\n            }\n        });\n\n        return nextGroupChild;\n    }\n    public findNextPureChild(\n        target: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ): ArrayChild | null {\n        const nextChild = this.findNextChild(target);\n\n        if (nextChild) {\n            return nextChild.findPureChild(target, range);\n        }\n        return null;\n    }\n    public getSingleChild(): SingleChild | null {\n        const groupElement = this.groupElement;\n\n        if (groupElement) {\n            const singleChild = this.parent?.value.find(t => t.value === groupElement);\n\n            if (singleChild) {\n                return singleChild as SingleChild;\n            }\n        }\n        return null;\n    }\n    public toTargetGroups(): TargetGroupsType {\n        return this.value.map(child => {\n            if (child.type === \"single\") {\n                return child.value;\n            } else {\n                return child.toTargetGroups();\n            }\n        });\n    }\n    public findArrayChild(targets: TargetGroupsType): ArrayChild | null {\n        const {\n            value,\n        } = this;\n\n        let result = false;\n\n        if (this.type !== \"root\") {\n            result = value.every(child => {\n                if (child.type === \"single\")  {\n                    return targets.some(target => child.value === target);\n                } else {\n                    return targets.some(target => {\n                        return isArray(target) && child.findArrayChild(target);\n                    });\n                }\n            });\n            // result = targets.every(target => {\n            //     if (isArray(target)) {\n            //         return value.some(child => {\n            //             return child.type === \"group\" && child.findArrayChild(target);\n            //         });\n            //     } else {\n            //         return map.get(target);\n            //     }\n            // });\n        }\n\n        if (result && targets.length === value.length) {\n            return this;\n        } else {\n            let childResult: ArrayChild | null = null;\n\n            value.some(child => {\n                if (child.type === \"group\") {\n                    childResult = child.findArrayChild(targets);\n\n                    return childResult;\n                }\n            });\n\n            return childResult;\n        }\n    }\n    public groupByPerfect(selected: Array<HTMLElement | SVGElement>) {\n        return this.value.filter(child => {\n            if (child.type !== \"single\") {\n                return child.compare(selected, -1);\n            }\n            return selected.indexOf(child.value) > -1;\n        }).map(child => {\n            if (child.type !== \"single\") {\n                const singleChild = child.getSingleChild();\n\n                if (singleChild) {\n                    return singleChild;\n                }\n            }\n            return child;\n        });\n    }\n    public add(targets: TargetGroupsObject) {\n        const {\n            value,\n            map,\n        } = this;\n\n        targets.forEach(child => {\n            if (\"groupId\" in child) {\n                const group = new ArrayChild(this);\n\n                group.id = child.groupId;\n                value.push(group);\n                group.add(child.children);\n            } else if (isArray(child)) {\n                const group = new ArrayChild(this);\n\n                value.push(group);\n                group.add(child);\n            } else {\n                const element = \"current\" in child ? child.current : child;\n                const single = new SingleChild(this, element!);\n\n                value.push(single);\n                map.set(element!, single);\n            }\n        });\n\n        value.forEach(child => {\n            if (child.type === \"single\") {\n                map.set(child.value, child);\n            } else {\n                child.map.forEach((nextChild, element) => {\n                    map.set(element, nextChild);\n                });\n            }\n        });\n\n        value.forEach(child => {\n            if  (child.type !== \"single\") {\n                return;\n            }\n            // single\n            const singleElement = child.value;\n            const groupChild = value.find(child2 => {\n                if (child2.type === \"single\") {\n                    return;\n                }\n                const firstElement = [...child2.map.keys()][0];\n\n                if (!firstElement) {\n                    return;\n                }\n\n                return singleElement.contains(firstElement);\n            });\n\n            (child as SingleChild).isGroupElement = !!groupChild;\n\n            if (groupChild) {\n                (groupChild as ArrayChild).groupElement = child.value;\n            }\n        });\n        return parent;\n    }\n}\n","/* eslint-disable no-cond-assign */\nimport { deepFlat, isArray } from \"@daybrush/utils\";\nimport { ArrayChild, SingleChild } from \"./groups\";\nimport { GroupChild, TargetGroupsObject, TargetGroupsType, TargetList } from \"./types\";\n\n\nexport function toTargetList(raw: GroupChild[]): TargetList {\n    function targets(childs: GroupChild[] = []) {\n        const arr: TargetGroupsType = [];\n\n        childs.forEach((child) => {\n            if (child.type === \"single\") {\n                arr.push(child.value);\n            } else {\n                arr.push(targets(child.value));\n            }\n        });\n\n        return arr;\n    }\n\n    return {\n        raw: () => raw,\n        targets() {\n            return targets(this.raw());\n        },\n        flatten() {\n            return deepFlat(this.targets());\n        },\n    };\n}\n\nexport class GroupManager extends ArrayChild {\n    public type = \"root\" as const;\n    private _targets:  Array<HTMLElement | SVGElement> = [];\n\n    constructor(\n        targetGroups: TargetGroupsType,\n        targets?: Array<HTMLElement | SVGElement>,\n    ) {\n        super();\n        this.set(targetGroups, targets);\n    }\n    public set(\n        targetGroups: TargetGroupsObject,\n        targets: Array<HTMLElement | SVGElement> = [],\n    ) {\n        this.map = new Map();\n        this.value = [];\n\n        const map = this.map;\n        const value = this.value;\n\n        this.add(targetGroups);\n        targets.forEach(target => {\n            if (map.has(target)) {\n                return;\n            }\n            const single = new SingleChild(this, target);\n\n            single.depth = 1;\n            value.push(single);\n            map.set(target, single);\n        });\n        this._targets = targets;\n    }\n    public selectSubChilds(targets: TargetGroupsType, target: HTMLElement | SVGElement) {\n        const root = this;\n        const nextChild = root.findNextChild(target, targets, false);\n        const targetChild = root.map.get(target);\n\n        let nextChilds: GroupChild[] = [];\n\n        if (nextChild) {\n            nextChilds = [nextChild];\n        } else if (targetChild) {\n            nextChilds = [targetChild];\n        } else {\n            nextChilds = [];\n        }\n\n        return toTargetList(nextChilds);\n    }\n    public selectSingleChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n    ) {\n        const nextTargets = [...targets];\n\n        // group can't be added, removed.\n        removed.forEach(element => {\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                nextTargets.splice(index, 1);\n            }\n        });\n\n        // Targets can be added one by one\n        added.forEach(element => {\n            nextTargets.push(element);\n        });\n\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public selectCompletedChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n        continueSelect?: boolean,\n    ) {\n        const nextTargets = [...targets];\n        const startSelected = deepFlat(nextTargets);\n\n        // group can be added, removed.\n        removed.forEach(element => {\n            // Single Target\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                // single target or group\n                nextTargets.splice(index, 1);\n                return;\n            }\n            // Group Target\n            const removedChild = continueSelect\n                // Finds the nearest child for element and nextTargets.\n                ? this.findNextChild(element, nextTargets)\n                // Find the nearest exact child for element, all removed and nextTargets.\n                : this.findNextExactChild(element, removed, nextTargets);\n\n            if (removedChild) {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && removedChild.compare(target);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n            }\n        });\n\n        added.forEach(element => {\n            const parentGroup = this._findParentGroup(element, startSelected);\n            const nextChild = parentGroup.findContainedChild(element);\n\n            if (nextChild?.type === \"group\") {\n                const singleChild = nextChild.getSingleChild();\n\n                if (singleChild) {\n                    nextTargets.push(singleChild.value);\n                } else {\n                    nextTargets.push(nextChild.toTargetGroups());\n                }\n                return;\n            }\n            nextTargets.push(element);\n        });\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public selectSameDepthChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n        continueSelect?: boolean,\n    ) {\n        const nextTargets = [...targets];\n        const commonParent = this.findCommonParent(nextTargets);\n\n        removed.forEach(element => {\n            // Single Target\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                // single target or group\n                nextTargets.splice(index, 1);\n                return;\n            }\n            const removedChild = continueSelect\n                // Find the nearest exact child for element, all removed and nextTargets.\n                ? commonParent.findNextExactChild(element, removed, nextTargets)\n                // Finds the nearest child for element and nextTargets.\n                : commonParent.findNextChild(element, nextTargets, true);\n\n            if (removedChild) {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && removedChild.compare(target);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n            }\n        });\n        const addedChildren = commonParent.groupByPerfect(added);\n\n        addedChildren.forEach(child => {\n            if (child.type === \"single\") {\n                nextTargets.push(child.value);\n            } else {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && child.compare(target, 1);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n                nextTargets.push(child.toTargetGroups());\n            }\n        });\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public toChilds(targets: TargetGroupsType): GroupChild[] {\n        const childs: GroupChild[] = [];\n\n        targets.forEach(target => {\n            if (isArray(target)) {\n                const arrayChild = this.findArrayChild(target);\n\n                if (arrayChild) {\n                    const singleChild = arrayChild.getSingleChild();\n\n                    if (singleChild) {\n                        return singleChild;\n                    }\n                    childs.push(arrayChild);\n                }\n            } else {\n                const single = this.map.get(target);\n\n                if (single) {\n                    childs.push(single);\n                } else {\n                    childs.push(new SingleChild(this, target));\n                }\n            }\n        });\n\n        return childs;\n    }\n    public findChild(element: HTMLElement | SVGElement, isAuto: true): SingleChild | ArrayChild;\n    public findChild(\n        element: HTMLElement | SVGElement,\n        isAuto?: boolean,\n    ): SingleChild | ArrayChild | undefined;\n    public findChild(\n        element: HTMLElement | SVGElement,\n        isAuto?: boolean,\n    ): SingleChild | ArrayChild | undefined {\n        const value = this.map.get(element);\n\n        if (isAuto) {\n            return value || new SingleChild(this, element);\n        }\n        return value;\n    }\n    public findArrayChildById(id: string): ArrayChild | null {\n        let value: ArrayChild | null = null;\n\n        this.value.some(function find(child: GroupChild) {\n            if (child.type !== \"single\") {\n                if (child.id === id) {\n                    value = child;\n                    return true;\n                } else {\n                    return child.value.some(find);\n                }\n            }\n        });\n\n        return value;\n    }\n    public group(targets: TargetGroupsType, flatten?: boolean): TargetGroupsType | null {\n        const commonParent = this.findCommonParent(targets);\n        const groupChilds = targets.map(target => {\n            if (isArray(target)) {\n                return this.findArrayChild(target);\n            }\n            return this.findChild(target);\n        });\n        const isGroupable = groupChilds.every(child => child?.parent === commonParent);\n\n        if (!isGroupable) {\n            return null;\n        }\n        const group = new ArrayChild(commonParent);\n        const nextChilds = commonParent.value.filter(target => groupChilds.indexOf(target) === -1);\n\n        if (!nextChilds.length) {\n            return null;\n        }\n        nextChilds.unshift(group);\n        group.add(flatten ? deepFlat(targets) : targets);\n        commonParent.value = nextChilds;\n\n        this.set(this.toTargetGroups(), this._targets);\n\n        return group.toTargetGroups();\n    }\n    public ungroup(targets: TargetGroupsType) {\n        if (targets.length === 1 && isArray(targets[0])) {\n            targets = targets[0];\n        }\n        const commonParent = this.findCommonParent(targets);\n        const groupChilds = targets.map(target => {\n            if (isArray(target)) {\n                return this.findArrayChild(target);\n            }\n            return this.findChild(target);\n        });\n\n        if (commonParent.groupElement) {\n            return null;\n        }\n\n        // all children is targets\n        const isGroupable = commonParent.value.every(child => groupChilds.indexOf(child) > -1);\n\n        if (!isGroupable || commonParent === this) {\n            // has no group\n            return null;\n        }\n\n        const parent = commonParent.parent;\n\n        if (!parent) {\n            return null;\n        }\n        const nextChilds = parent.value.filter(target => target !== commonParent);\n\n        nextChilds.push(...commonParent.value);\n        parent.value = nextChilds;\n\n        this.set(this.toTargetGroups(), this._targets);\n        return commonParent.toTargetGroups();\n    }\n    protected _findParentGroup(\n        element: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ) {\n        if (!range.length) {\n            return this;\n        }\n        const single = this.map.get(element);\n\n        if (!single) {\n            return this;\n        }\n        let parent: ArrayChild | undefined = single.parent;\n\n        while (parent) {\n            if (range.some(element => parent!.contains(element))) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return this;\n    }\n}\n"],"names":["Child","parent","this","type","depth","_scope","Object","defineProperty","prototype","get","__spreadArray","scope","id","SingleChild","_super","value","_this","call","isGroupElement","__extends","ArrayChild","apply","arguments","groupElement","map","Map","__proto","compare","groups","checker","elements","deepFlat","elementsLength","length","mapSize","size","sizeDiff","count","filter","element","has","target","contains","some","child","findContainedChild","find","findExactChild","isArray","flatted","single","findCommonParent","targets","Infinity","childs","forEach","Math","min","firstChild","every","findNextChild","range","isExact","nextChild","toTargetGroups","nextGroupChild","findNextExactChild","selected","findPureChild","childSelected","findNextPureChild","getSingleChild","singleChild","_a","t","findArrayChild","childResult_1","result","groupByPerfect","indexOf","add","group","groupId","push","children","current","set","singleElement","groupChild","child2","firstElement","keys","toTargetList","raw","arr","flatten","GroupManager","targetGroups","_targets","selectSubChilds","targetChild","selectSingleChilds","added","removed","nextTargets","index","splice","toChilds","selectCompletedChilds","continueSelect","startSelected","removedChild","groupIndex","findIndex","_findParentGroup","selectSameDepthChilds","commonParent","arrayChild","findChild","isAuto","findArrayChildById","nextChilds","groupChilds","unshift","ungroup"],"mappings":";;;;;;;;moCAGA,IAAAA,EAAA,WAII,SAAAA,EAAmBC,GAAAC,KAAMD,OAANA,EAHZC,KAAIC,KAAgC,SACpCD,KAAKE,MAAG,EACLF,KAAMG,OAAa,GAErBJ,IACAC,KAAKE,MAAQH,EAAOG,MAAQ,EAEnC,CAUL,OARIE,OAAAC,eAVJP,EAAAQ,UAUoB,QAAA,CAAhBC,IAAA,WACI,IAAMR,EAASC,KAAKD,OAEpB,OAAKA,GAA0B,SAAhBA,EAAOE,KAGtBO,EAAAA,EAAA,GAAWT,EAAOU,QAAlB,GAAyBV,EAAOW,IAAI,CAAA,CAApC,EAFW,EAJC,gCAAhB,EAQHZ,CAAA,IAEDa,EAAA,SAAAC,GAGI,SAAYD,EAAAZ,EAA2Bc,GACnCC,EAAAF,EAAAG,KAAAf,KAAMD,CAAN,GACHC,YAFsCc,EAAKD,MAALA,EAFhCC,EAAIb,KAAG,SACPa,EAAcE,eAAG,CAAA,GAGvB,CACL,OANiCC,EAAKN,EAAAC,CAAA,EAMrCD,CAND,EAAiCb,CAAjC,EASAoB,EAAA,SAAAN,GAAA,SAAAM,IAAA,IA0VCJ,EAAA,OAAAF,GAAAA,EAAAO,MAAAnB,KAAAoB,SAAA,GAAApB,YAzVUc,EAAIb,KAAqB,QACzBa,EAAKD,MAAiB,GACtBC,EAAEJ,GAAG,GACLI,EAAYO,aAAqC,KACjDP,EAAAQ,IAAkD,IAAIC,KAqVhE,CA1V+BN,EAAKC,EAAAN,CAAA,EAArC,IAAAY,EAAAN,EAAAZ,UA0VA,OAnVWkB,EAAAC,QAAP,SAAeC,EAA0BC,GAAA,KAAA,IAAAA,IAAAA,EAAuB,GAC5D,IAAMC,EAAWC,EAASH,CAAD,EACnBJ,EAAMtB,KAAKsB,IACXQ,EAAiBF,EAASG,OAC1BC,EAAUV,EAAIW,KACdC,EAAWF,EAAUF,EAKrBK,EAAQP,EAASQ,OAAO,SAAAC,GAAW,OAAAf,EAAIgB,IAAID,CAAR,CAA3B,CAAA,EAA6CN,OAE3D,OAAe,EAAVJ,GAA2B,GAAZO,GAA+B,IAAZP,GAA8B,GAAbO,EAC7CJ,IAAmBK,EACnBR,EAAU,GAAKO,GAAY,GAC3BF,IAAYG,GAIpBX,EAAGc,IAAV,SAAWC,GACP,OAAOvC,KAAKsB,IAAIgB,IAAIC,CAAb,GAEJf,EAAQgB,SAAf,SAAgBH,GACZ,MAAIrC,CAAAA,CAAAA,KAAKsC,IAAID,CAAT,GAGGrC,KAAKa,MAAM4B,KAAK,SAAAC,GACnB,MAAmB,UAAfA,EAAMzC,MACCyC,EAAMF,SAASH,CAAf,CAId,CANM,GAQJb,EAAkBmB,mBAAzB,SAA0BN,GACtB,OAAOO,EAAK5C,KAAKa,MAAO,SAAA6B,GACpB,MAAmB,WAAfA,EAAMzC,KACCyC,EAAM7B,QAAUwB,EAEhBK,EAAMF,SAASH,CAAf,CAEd,CANU,GAWRb,EAAcqB,eAArB,SAAsBN,GAClB,IAAMjB,EAAMtB,KAAKsB,IAEjB,GAAI,CAACwB,EAAQP,CAAD,EACR,OAAOjB,EAAIf,IAAIgC,CAAR,EAEX,IAAMQ,EAAUlB,EAASU,CAAD,EAClBR,EAASgB,EAAQhB,OACjBiB,EAAS1B,EAAIf,IAAIwC,EAAQ,EAAhB,EAEf,GAAKC,EAML,IAFA,IAAIjD,EAAiCiD,EAAOjD,OAErCA,GAAQ,CACX,GAAIA,EAAOuB,IAAIW,MAAQF,EACnB,OAAOhC,EAEXA,EAASA,EAAOA,MACnB,GAGEyB,EAAgByB,iBAAvB,SAAwBC,GAWpB,IAXJ,IAkCCpC,EAAAd,KAjCOE,EAAQiD,EAAAA,EACRC,EAASF,EAAQ5B,IAAI,SAAAiB,GAAU,OAAAzB,EAAK+B,eAAeN,CAApB,CAA2B,CAAjD,KAEba,EAAOC,QAAQ,SAAAX,GACNA,IAGLxC,EAAQoD,KAAKC,IAAIb,EAAMxC,MAAOA,CAAtB,GAJZ,QAOOA,GAAK,kBACR,EAAEA,EAUF,IAAMsD,GATNJ,EAASA,EAAO9B,IAAI,SAAAoB,GAGhB,IAFA,IAAI3C,EAAiC2C,EAE9B3C,GAAUA,EAAOG,QAAUA,GAC9BH,EAASA,EAAOA,OAGpB,OAAOA,CACV,CARQ,GASiB6C,KAAK,SAAAF,GAAS,OAAAA,CAAK,CAA1B,EAEnB,OAAKc,EAGDJ,EAAOK,MAAM,SAAAf,GAAS,MAAA,CAACA,GAASA,IAAUc,CAAU,CAApD,UAAJ,KAAA,wEAGH,CAGD,OAFqBJ,EAAOR,KAAK,SAAAF,GAAS,OAAAA,CAAK,CAA1B,GAEE1C,MAEpBwB,EAAAkC,cAAP,SACInB,EACAoB,EACAC,GAHJ,IA+BC9C,EAAAd,KA1BO6D,GAHJ,KAAA,IAAAF,IAAAA,EAA0B3D,KAAK8D,kBAC/B,KAAA,IAAAF,IAAAA,EAAc,CAAA,GAEqB,MAE7B7B,EAAS4B,EAAM5B,OAuBrB,OArBA4B,EAAMlB,KAAK,SAAAC,GACP,MAAI,CAACkB,GAAsB,IAAX7B,GAAgBe,EAAQJ,CAAD,EACnCmB,EAAY/C,EAAK4C,cAAcnB,EAAQG,CAA3B,GAKVqB,EAAiBjD,EAAK+B,eAAeH,CAApB,IAMnB,QAASqB,GACLA,EAAezC,IAAIgB,IAAIC,CAAvB,GACAsB,EAAYE,EACL,CAAA,GAPf,KAAA,EATJ,EAqBOF,GAEJrC,EAAAwC,mBAAP,SACIzB,EACA0B,EACAN,GAAA,KAAA,IAAAA,IAAAA,EAA0B3D,KAAK8D,kBAIzBD,EAAY7D,KAAK0D,cAAcnB,EAAQoB,EAAO,CAAA,CAAlC,EAElB,OAAKE,GAIDA,EAAUpC,QAAQwC,EAAU,CAAC,CAA7B,EACOJ,EAJA,MAWRrC,EAAA0C,cAAP,SACI3B,EACAoB,GAFJ,IAuBC7C,EAAAd,KAnBO+D,EAAoC,KAElCI,EAAgBR,EAAMvB,OAAO,SAAAC,GAAW,OAAAvB,EAAKwB,IAAID,CAAT,CAAiB,CAAzC,EAEtB,OAAK8B,EAAcpC,QAInB/B,KAAKa,MAAM4B,KAAK,SAAAoB,GACZ,GAAuB,WAAnBA,EAAU5D,MAAqB4D,EAAUvB,IAAIC,CAAd,IAC/BwB,EAAiBF,EAAUK,cAAc3B,EAAQ4B,CAAhC,GAGb,MAAO,CAAA,EALnB,EAUOJ,GAbI/D,MAeRwB,EAAA4C,kBAAP,SACI7B,EACAoB,GAEA,IAAME,EAAY7D,KAAK0D,cAAcnB,CAAnB,EAElB,OAAIsB,EACOA,EAAUK,cAAc3B,EAAQoB,CAAhC,EAEJ,MAEJnC,EAAA6C,eAAP,eACUhD,EAAerB,KAAKqB,aAE1B,GAAIA,EAAc,CACd,IAAMiD,EAAc,OAAAC,EAAAvE,KAAKD,QAAM,KAAA,EAAAwE,EAAE1D,MAAM+B,KAAK,SAAA4B,GAAK,OAAAA,EAAE3D,QAAUQ,CAAY,CAA1C,EAE/B,GAAIiD,EACA,OAAOA,CAEd,CACD,OAAO,MAEJ9C,EAAAsC,eAAP,WACI,OAAO9D,KAAKa,MAAMS,IAAI,SAAAoB,GAClB,MAAmB,WAAfA,EAAMzC,KACCyC,EAAM7B,MAEN6B,EAAMoB,gBAEpB,CANM,GAQJtC,EAAciD,eAArB,SAAsBvB,GAEd,IA6BIwB,EA7BJ7D,EACAb,KAAIa,MAEJ8D,EAAS,CAAA,EAuBb,OApBIA,EADc,SAAd3E,KAAKC,KACIY,EAAM4C,MAAM,SAAAf,GACjB,MAAmB,WAAfA,EAAMzC,KACCiD,EAAQT,KAAK,SAAAF,GAAU,OAAAG,EAAM7B,QAAU0B,CAAM,CAA7C,EAEAW,EAAQT,KAAK,SAAAF,GAChB,OAAOO,EAAQP,CAAD,GAAYG,EAAM+B,eAAelC,CAArB,CAC7B,CAFM,EAJN,EAoBToC,IAAUzB,EAAQnB,SAAWlB,EAAMkB,OAC5B/B,MAEH0E,EAAiC,KAErC7D,EAAM4B,KAAK,SAAAC,GACP,GAAmB,UAAfA,EAAMzC,KAGN,OAFAyE,EAAchC,EAAM+B,eAAevB,CAArB,EAFtB,EAQOwB,IAGRlD,EAAcoD,eAArB,SAAsBX,GAClB,OAAOjE,KAAKa,MAAMuB,OAAO,SAAAM,GACrB,MAAmB,WAAfA,EAAMzC,KACCyC,EAAMjB,QAAQwC,EAAU,CAAC,CAAzB,EAE4B,CAAC,EAAjCA,EAASY,QAAQnC,EAAM7B,KAAvB,CACV,CALM,EAKJS,IAAI,SAAAoB,GACH,GAAmB,WAAfA,EAAMzC,KAAmB,CACzB,IAAMqE,EAAc5B,EAAM2B,iBAE1B,GAAIC,EACA,OAAOA,CAEd,CACD,OAAO5B,CACV,CAdM,GAgBJlB,EAAGsD,IAAV,SAAW5B,GAAX,IA+DCpC,EAAAd,KA7DOa,EAEAb,WADAsB,EACAtB,SA0DJ,OAxDAkD,EAAQG,QAAQ,SAAAX,GACZ,IAYUL,EAZN,YAAaK,IAGbqC,EAFc,IAAI7D,EAAWJ,CAAf,GAERJ,GAAKgC,EAAMsC,QACjBnE,EAAMoE,KAAKF,CAAX,EACAA,EAAMD,IAAIpC,EAAMwC,QAAhB,GACOpC,EAAQJ,CAAD,GACRqC,EAAQ,IAAI7D,EAAWJ,CAAf,EAEdD,EAAMoE,KAAKF,CAAX,EACAA,EAAMD,IAAIpC,CAAV,IAEML,EAAU,YAAaK,EAAQA,EAAMyC,QAAUzC,EAC/CM,EAAS,IAAIrC,EAAYG,EAAMuB,CAAtB,EAEfxB,EAAMoE,KAAKjC,CAAX,EACA1B,EAAI8D,IAAI/C,EAAUW,CAAlB,GAjBR,EAqBAnC,EAAMwC,QAAQ,SAAAX,GACS,WAAfA,EAAMzC,KACNqB,EAAI8D,IAAI1C,EAAM7B,MAAO6B,CAArB,EAEAA,EAAMpB,IAAI+B,QAAQ,SAACQ,EAAWxB,GAC1Bf,EAAI8D,IAAI/C,EAASwB,CAAjB,EADJ,EAJR,EAUAhD,EAAMwC,QAAQ,SAAAX,GACV,IAIM2C,EACAC,EALc,WAAf5C,EAAMzC,OAILoF,EAAgB3C,EAAM7B,MACtByE,EAAazE,EAAM+B,KAAK,SAAA2C,GAC1B,GAAoB,WAAhBA,EAAOtF,KAAX,CAGMuF,EAAehF,EAAI,GAAA+E,EAAOjE,IAAImE,OAAM,CAAA,CAAjB,EAAmB,GAE5C,GAAKD,EAIL,OAAOH,EAAc7C,SAASgD,CAAvB,CAPN,CAQJ,CAXkB,EAalB9C,EAAsB1B,eAAiB,CAAC,CAACsE,EAEtCA,KACCA,EAA0BjE,aAAeqB,EAAM7B,OAtBxD,EAyBOd,QAEdmB,CA1VD,EAAgCpB,CAAhC,EC1BM,SAAU4F,EAAaC,GAezB,MAAO,CACHA,IAAK,WAAM,OAAAA,CADR,EAEHzC,QAAO,WACH,OAjBR,SAASA,EAAQE,GACb,IAAMwC,EAAwB,GAU9B,OAXaxC,EAAA,KAAA,IAAAA,EAAyB,GAGtCA,GAAOC,QAAQ,SAACX,GACO,WAAfA,EAAMzC,KACN2F,EAAIX,KAAKvC,EAAM7B,KAAf,EAEA+E,EAAIX,KAAK/B,EAAQR,EAAM7B,KAAP,CAAhB,EAJR,EAQO+E,CACV,EAKsB5F,KAAK2F,IAAL,CAAD,CAHf,EAKHE,QAAO,WACH,OAAOhE,EAAS7B,KAAKkD,QAAL,CAAD,CAClB,EAER,sFAED,SAAAtC,GAII,SACIkF,EAAAC,EACA7C,GAFJ,IAAApC,EAIIF,WAAA,GAEHZ,YATMc,EAAIb,KAAG,OACNa,EAAQkF,SAAqC,GAOjDlF,EAAKsE,IAAIW,EAAc7C,CAAvB,GACH,CAV6BjC,EAAU6E,EAAAlF,CAAA,EAA5C,IAAAY,EAAAsE,EAAAxF,UAuUA,OA5TWkB,EAAA4D,IAAP,SACIW,EACA7C,GAFJ,IAsBCpC,EAAAd,KAfSsB,GALN,KAAA,IAAA4B,IAAAA,EAA6C,IAE7ClD,KAAKsB,IAAM,IAAIC,IACfvB,KAAKa,MAAQ,GAEDb,KAAKsB,KACXT,EAAQb,KAAKa,MAEnBb,KAAK8E,IAAIiB,CAAT,EACA7C,EAAQG,QAAQ,SAAAd,GACZ,IAGMS,EAHF1B,EAAIgB,IAAIC,CAAR,KAGES,EAAS,IAAIrC,EAAYG,EAAMyB,CAAtB,GAERrC,MAAQ,EACfW,EAAMoE,KAAKjC,CAAX,EACA1B,EAAI8D,IAAI7C,EAAQS,CAAhB,GARJ,EAUAhD,KAAKgG,SAAW9C,GAEb1B,EAAAyE,gBAAP,SAAuB/C,EAA2BX,GAExCsB,EADO7D,KACU0D,cAAcnB,EAAQW,EAAS,CAAA,CAApC,EACZgD,EAFOlG,KAEYsB,IAAIf,IAAIgC,CAAb,EAYpB,OAAOmD,EARH7B,EACa,CAACA,GACPqC,EACM,CAACA,GAED,EAGE,GAEhB1E,EAAA2E,mBAAP,SACIjD,EACAkD,EACAC,GAEA,IAAMC,EAAW9F,EAAA,GAAO0C,EAAO,CAAA,CAAd,EAgBjB,OAbAmD,EAAQhD,QAAQ,SAAAhB,GACNkE,EAAQD,EAAYzB,QAAQxC,CAApB,EAEF,CAAC,EAATkE,GACAD,EAAYE,OAAOD,EAAO,CAA1B,CAEP,CAND,EASAH,EAAM/C,QAAQ,SAAAhB,GACViE,EAAYrB,KAAK5C,CAAjB,EADJ,EAIOqD,EAAa1F,KAAKyG,SAASH,CAAd,CAAD,GAEhB9E,EAAqBkF,sBAA5B,SACIxD,EACAkD,EACAC,EACAM,GAJJ,IAsDC7F,EAAAd,KAhDSsG,EAAW9F,EAAA,GAAO0C,EAAO,CAAA,CAAd,EACX0D,EAAgB/E,EAASyE,CAAD,EA8C9B,OA3CAD,EAAQhD,QAAQ,SAAAhB,GAEZ,IAQMwE,EARAN,EAAQD,EAAYzB,QAAQxC,CAApB,GAEF,CAAC,EAATkE,IAMEM,EAAeF,EAEf7F,EAAK4C,cAAcrB,EAASiE,CAA5B,EAEAxF,EAAKkD,mBAAmB3B,EAASgE,EAASC,CAA1C,IAOe,CAAC,GAJZQ,EAAaR,EAAYS,UAAU,SAAAxE,GACrC,OAAOO,EAAQP,CAAD,GAAYsE,EAAapF,QAAQc,CAArB,CAC7B,CAFkB,KAKf+D,EAAYE,OAAOM,EAAY,CAA/B,EAtBZ,EA2BAV,EAAM/C,QAAQ,SAAAhB,GACV,IAIUiC,EAHJT,EADc/C,EAAKkG,iBAAiB3E,EAASuE,CAA/B,EACUjE,mBAAmBN,CAA/B,EAEM,WAApBwB,MAAAA,EAAS,KAAA,EAATA,EAAW5D,OACLqE,EAAcT,EAAUQ,kBAG1BiC,EAAYrB,KAAKX,EAAYzD,KAA7B,EAEAyF,EAAYrB,KAAKpB,EAAUC,eAA3B,CAAA,EAIRwC,EAAYrB,KAAK5C,CAAjB,EAdJ,EAgBOqD,EAAa1F,KAAKyG,SAASH,CAAd,CAAD,GAEhB9E,EAAqByF,sBAA5B,SACI/D,EACAkD,EACAC,EACAM,GAEA,IAAML,EAAW9F,EAAA,GAAO0C,EAAO,CAAA,CAAd,EACXgE,EAAelH,KAAKiD,iBAAiBqD,CAAtB,EA2CrB,OAzCAD,EAAQhD,QAAQ,SAAAhB,GAEZ,IAOMwE,EAPAN,EAAQD,EAAYzB,QAAQxC,CAApB,GAEF,CAAC,EAATkE,IAKEM,EAAeF,EAEfO,EAAalD,mBAAmB3B,EAASgE,EAASC,CAAlD,EAEAY,EAAaxD,cAAcrB,EAASiE,EAAa,CAAA,CAAjD,IAOe,CAAC,GAJZQ,EAAaR,EAAYS,UAAU,SAAAxE,GACrC,OAAOO,EAAQP,CAAD,GAAYsE,EAAapF,QAAQc,CAArB,CAC7B,CAFkB,KAKf+D,EAAYE,OAAOM,EAAY,CAA/B,EArBZ,EAyBsBI,EAAatC,eAAewB,CAA5B,EAER/C,QAAQ,SAAAX,GAClB,IAGUoE,EAHS,WAAfpE,EAAMzC,KACNqG,EAAYrB,KAAKvC,EAAM7B,KAAvB,GAMiB,CAAC,GAJZiG,EAAaR,EAAYS,UAAU,SAAAxE,GACrC,OAAOO,EAAQP,CAAD,GAAYG,EAAMjB,QAAQc,EAAQ,CAAtB,CAC7B,CAFkB,IAKf+D,EAAYE,OAAOM,EAAY,CAA/B,EAEJR,EAAYrB,KAAKvC,EAAMoB,eAAvB,CAAA,GAXR,EAcO4B,EAAa1F,KAAKyG,SAASH,CAAd,CAAD,GAEhB9E,EAAQiF,SAAf,SAAgBvD,GAAhB,IA2BCpC,EAAAd,KA1BSoD,EAAuB,GAyB7B,OAvBAF,EAAQG,QAAQ,SAAAd,GACZ,GAAIO,EAAQP,CAAD,EAAU,CACjB,IAAM4E,EAAarG,EAAK2D,eAAelC,CAApB,EAEnB,GAAI4E,EAAY,CACZ,IAAM7C,EAAc6C,EAAW9C,iBAE/B,GAAIC,EACA,OAAOA,EAEXlB,EAAO6B,KAAKkC,CAAZ,CACH,CACJ,KAAM,CACGnE,EAASlC,EAAKQ,IAAIf,IAAIgC,CAAb,EAGXa,EAAO6B,KADPjC,GAGY,IAAIrC,EAAYG,EAAMyB,CAAtB,CAFZ,CAIP,EApBL,EAuBOa,GAOJ5B,EAAA4F,UAAP,SACI/E,EACAgF,GAEA,IAAMxG,EAAQb,KAAKsB,IAAIf,IAAI8B,CAAb,EAEd,OAAIgF,EACOxG,GAAS,IAAIF,EAAYX,KAAMqC,CAAtB,EAEbxB,GAEJW,EAAkB8F,mBAAzB,SAA0B5G,GACtB,IAAIG,EAA2B,KAa/B,OAXAb,KAAKa,MAAM4B,KAAK,SAASG,EAAKF,GAC1B,GAAmB,WAAfA,EAAMzC,KACN,OAAIyC,EAAMhC,KAAOA,GACbG,EAAQ6B,EACD,CAAA,GAEAA,EAAM7B,MAAM4B,KAAKG,CAAjB,EANnB,EAWO/B,GAEJW,EAAAuD,MAAP,SAAa7B,EAA2B2C,GAAxC,IAaUd,EACAwC,EAYTzG,EAAAd,KAzBSkH,EAAelH,KAAKiD,iBAAiBC,CAAtB,EACfsE,EAActE,EAAQ5B,IAAI,SAAAiB,GAC5B,OAAIO,EAAQP,CAAD,EACAzB,EAAK2D,eAAelC,CAApB,EAEJzB,EAAKsG,UAAU7E,CAAf,CACV,CALmB,EAQpB,OAFoBiF,EAAY/D,MAAM,SAAAf,GAAS,OAAAA,MAAAA,EAAA,KAAA,EAAAA,EAAO3C,UAAWmH,CAAY,CAAzD,IAKdnC,EAAQ,IAAI7D,EAAWgG,CAAf,GACRK,EAAaL,EAAarG,MAAMuB,OAAO,SAAAG,GAAU,MAAgC,CAAC,IAAjCiF,EAAY3C,QAAQtC,CAApB,CAAkC,CAAtE,GAEHR,SAGhBwF,EAAWE,QAAQ1C,CAAnB,EACAA,EAAMD,IAAIe,EAAUhE,EAASqB,CAAD,EAAYA,CAAxC,EACAgE,EAAarG,MAAQ0G,EAErBvH,KAAKoF,IAAIpF,KAAK8D,eAAL,EAAuB9D,KAAKgG,QAArC,EAEOjB,EAAMjB,kBAdF,MAgBRtC,EAAOkG,QAAd,SAAexE,GAAf,IA6BUqE,EAOTzG,EAAAd,KAhCSkH,GAHiB,IAAnBhE,EAAQnB,QAAgBe,EAAQI,EAAQ,EAAT,IAC/BA,EAAUA,EAAQ,IAEDlD,KAAKiD,iBAAiBC,CAAtB,GACfsE,EAActE,EAAQ5B,IAAI,SAAAiB,GAC5B,OAAIO,EAAQP,CAAD,EACAzB,EAAK2D,eAAelC,CAApB,EAEJzB,EAAKsG,UAAU7E,CAAf,CACV,CALmB,EAOpB,MAAI2E,CAAAA,EAAa7F,cAKG6F,EAAarG,MAAM4C,MAAM,SAAAf,GAAS,MAA6B,CAAC,EAA9B8E,EAAY3C,QAAQnC,CAApB,CAA+B,CAAjE,GAEAwE,IAAiBlH,OAK/BD,EAASmH,EAAanH,UAKtBwH,EAAaxH,EAAOc,MAAMuB,OAAO,SAAAG,GAAU,OAAAA,IAAW2E,CAAY,CAArD,GAERjC,KAAX9D,MAAAoG,EAAmBL,EAAarG,KAAhC,EACAd,EAAOc,MAAQ0G,EAEfvH,KAAKoF,IAAIpF,KAAK8D,eAAL,EAAuB9D,KAAKgG,QAArC,EACOkB,EAAapD,kBAdT,MAgBLtC,EAAAwF,iBAAV,SACI3E,EACAsB,GAEA,GAAKA,EAAM5B,OAAX,CAGMiB,EAAShD,KAAKsB,IAAIf,IAAI8B,CAAb,EAEf,GAAKW,EAKL,IAFA,IAAIjD,EAAiCiD,EAAOjD,OAErCA,GAAQ,CACX,GAAI4D,EAAMlB,KAAK,SAAAJ,GAAW,OAAAtC,EAAQyC,SAASH,CAAjB,CAAyB,CAA/C,EACA,OAAOtC,EAEXA,EAASA,EAAOA,MACnB,CAbA,CAcD,OAAOC,MAEd8F,CAvUD,EAAkC5E,CAAlC"}